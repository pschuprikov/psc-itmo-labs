\section{Реализация}\label{implementation}
Рассмотренный в предыдущем разделе метод был реализован в рамках коммерческой системы визуализации
\emph{Frigate}, ориентированной библиотеки компьютерной графики, реализующие стандарт \emph{OpenGL}. 
Основными используемыми языками программирования были \emph{C++}, информацию о котором можно найти в
\cite{stroustrup}, и язык \emph{GLSL} (OpenGL Shading Language), соответствующий спецификации \cite{glslspec}.
Основной средой разработки была \emph{Microsoft Visual Studio}, также для отладки шейдеров,
использовалась проект с открытым исходным кодом \emph{GLIntercept}.

\subsection{Кусочно-линейный скелет}
В данной работе использовалась реализация алгоритма построения кусочно-линейного скелета,
основанная на модификации \cite{skeleton_azmanov} алгоритма \cite{skeleton}, имеющаяся 
в инфраструктуре системы визуализации \emph{Frigate}. Асимптотика данной реализации 
$O(n m + n \log n)$, где $n$ --- число вершин полигона, а $m$ --- число вогнутых вершин полигона.
Поскольку для нашей задачи требуется построить кусочно-линейный скелет с обоих сторон от полигона,
при смене стороны вогнутые вершины становятся выпуклыми и наоборот, поэтому итоговая ассимптотика 
построения кусочно-линейного скелета: $O(n^2 + n \log n)$

\subsection{Графический конвейер OpenGL}
Графический конвейер OpenGL состоит из множества различных стадий, часть из которых 
не поддается контролю пользователя, часть --- предоставляет пользователю ограниченные возможности
для настройки, и, наконец, часть  является полностью программируемой и состоит из т. н. 
шейдеров (англ.~shader) --- программ, выполняющихся на графическом процессоре 
в специфичном окружении \emph{OpenGL}, для написания которых используется язык программирования 
GLSL. Важными для реализации предлагаемого метода, являются программируемые стадии, а также 
ряд частично доступных настройке пользователем. Подробнее о библиотеке \emph{OpenGL} и структуре
графического конвейера можно найти в \cite{glspec,realtime}.

\subsubsection{Программируемая функциональность}
В рамках OpenGL выделяется три типа шейдеров, использованных в работе:
\begin{itemize}
\item \b{Вершинный.} Входная стадия графического конвейера, на которую пользователь предоставляет
необходимые для отрисовки данные о вершинах визуализируемого объекта, такие как: позиция вершины 
в мировой системе координат, вектор нормали к поверхности, текстурные координаты, цвет вершины 
и т. д. Задачей этого шейдера является подготовка данных вершин для дальнейших стадий конвейера.
\item \b{Геометрический.} На данной стадии собирается информация об отдельных вершинах, 
визуализируемой геометрии, и на ее основе порождаются те треугольники (четырехугольники, точки, отрезки), 
которые будут отправлены на следующие стадии для последующей визуализации.
\item \b{Фрагментный.} Собирает данные о фрагменте (элемент треугольника, попавший в заданный
пиксель выходного окна), с предыдущих стадий и вычисляет соответствующие ему значений, которые 
будут далее будут записаны в буферы цвета, глубины и др. на соответствующее фрагменту место.
\end{itemize}

\subsubsection{Настраиваемая функциональность}
Нас будут интересовать лишь две настраиваемых функциональности: 
\begin{enumerate}
\item Буфер глубины, stencil буфер 
и предоставляемые ими: тест глубины, решающий расположен ли новый фрагмент ближе или 
дальше, чем ранее обработанный фрагмент в том же пикселе окна; stencil-тест,
который на основе предыдущих решений теста глубины может запретить генерацию фрагментов в 
определенном пикселе окна.
\item Смешивание (англ.~blending) новых и старых данных буфера, настраивающий формулы, по которым
эти данные комбинируются.
\end{enumerate}

\subsection{Метод проекции на буфер глубины}\label{impl_volume_decals}
Каждый элемент разбиения кусочно-линейного скелета (см.~\ref{subdivision}) 
отправляется на графический конвейер как отдельная вершина, при этом вся информация об этом
элементе такая, как (для каждой вершины трапеции или треугольника): координаты в мировой 
системе координат, аппроксимации производных и 
береговые координаты, сохраняется как вершинные данные, которые вершинный шейдер передает далее
без изменений.

Затем геометрический шейдер генерирует из полученных данных прямоугольную трапецию, основаниями 
которых служат элементы разбиения, смещенные на такие высоты, чтобы призма полностью 
заключала в себя ландшафт или водную поверхность, проекции которых вдоль высоты лежат внутри
элемента разбиения. Эта призма затем проходит стадию растеризации и попавшие в нее фрагменты
обрабатываются согласно алгоритмам во фрагментном шейдере.

\subsection{Представление шума, и других функций на стадии отрисовки}
Функции $g$, $\mathrm{noise}_\mathrm{lf}$, $\mathrm{noise}_\mathrm{hf}$ и $\phi$, о которых 
шла речь в разделе (\ref{trains}), определяются некоторым периодичным образом, затем 
значение каждой функции за один сохраняется в виде текстур \emph{OpenGL}, доступных фрагментному 
шейдеру. Затем, используя встроенные в графическую библиотеку возможности, значения на периоде 
распространяются на все соответствующие области определения прозрачным для программиста 
фрагментного шейдера образом.

\subsection{Интеграция с коммерческой системой визуализации \emph{Frigate}}
Поскольку в рамках данной системы визуализации g-буферы, используемые при
визуализации ландшафта и водной поверхности, полностью разделены между собой (кроме 
буфера глубины), то запуск визуализации эффекта <<мокрого песка>> отделен это 
запуска эффектов наката прибрежной волны и прибоя.

Эффекты наката прибрежной волны и прибоя обладают непересекающимеся областями
действия: первый визуализирует водную поверхность и прибой на ландшафте, не покрытом водой; а
второй накладывается уже поверх готовой водной поверхность (и поэтому не требует дополнительных 
вычислительных ресурсов на ее визуализацию). Поэтому для того, чтобы сэкономить число 
обрабатываемых фрагментов, в тот момент, когда система \emph{Frigate} вела отрисовку
водную поверхность поверх ландшафта, графический конвейер был настроен таким образом, что 
пиксели, на которые попали прошедшие тест глубины фрагменты помечались в stencil-буфере 
специальным образом. В результате этого стало возможным различать эти пиксели и избавиться 
от лишних запусков фрагментных шейдеров.


