\section{Реализация}\label{implementation}
Рассмотренный в предыдущем разделе метод был реализован в рамках коммерческой системы визуализации
\emph{Frigate}, ориентированной на использование библиотеки компьютерной графики, реализующие стандарт \emph{OpenGL}. 
Основными используемыми языками программирования были \emph{C++}, информацию о котором можно найти в
\cite{stroustrup}, и язык \emph{GLSL} (OpenGL Shading Language), соответствующий спецификации \cite{glslspec}.
Основной средой разработки была \emph{Microsoft Visual Studio}, также для отладки шейдеров,
использовалась проект с открытым исходным кодом \emph{GLIntercept}.

\subsection{Кусочно-линейный скелет}
В данной работе использовалась реализация алгоритма построения кусочно-линейного скелета,
основанная на модификации \cite{skeleton_azmanov} алгоритма \cite{skeleton}, имеющаяся 
в инфраструктуре системы визуализации \emph{Frigate}. Асимптотика данной реализации 
$O(n m + n \log n)$, где $n$ --- число вершин полигона, а $m$ --- число вогнутых вершин полигона.
Поскольку для нашей задачи требуется построить кусочно-линейный скелет с обоих сторон от полигона,
при смене стороны вогнутые вершины становятся выпуклыми и наоборот, поэтому итоговая ассимптотика 
построения кусочно-линейного скелета: $O(n^2 + n \log n)$

\subsection{Графический конвейер OpenGL}
Графический конвейер OpenGL состоит из множества различных стадий, часть из которых 
не поддается контролю пользователя, часть --- предоставляет пользователю ограниченные возможности
для настройки, и, наконец, часть  является полностью программируемой и состоит из т. н. 
шейдеров (англ.~shader) --- программ, выполняющихся на графическом процессоре 
в специфичном окружении \emph{OpenGL}, для написания которых используется язык программирования 
GLSL. Важными для реализации предлагаемого метода, являются программируемые стадии, а также 
ряд частично доступных настройке пользователем. Подробную информацию о стандарте \emph{OpenGL} и структуре
графического конвейера можно найти в \cite{glspec,realtime}.

\subsubsection{Программируемая функциональность}
В рамках OpenGL выделяется три типа шейдеров, использованных в работе:
\begin{itemize}
\item \b{Вершинный.} Входная стадия графического конвейера, на которую пользователь предоставляет
необходимые для отрисовки данные о вершинах визуализируемого объекта, такие как: позиция вершины 
в мировой системе координат, вектор нормали к поверхности, текстурные координаты, цвет вершины 
и т. д. Задачей этого шейдера является подготовка данных вершин для дальнейших стадий конвейера.
\item \b{Геометрический.} На данной стадии собирается информация об отдельных вершинах, 
визуализируемой геометрии, и на ее основе порождаются те треугольники (четырехугольники, точки, отрезки), 
которые будут отправлены на следующие стадии для последующей визуализации.
\item \b{Фрагментный.} Собирает данные о фрагменте (элемент треугольника, попавший в заданный
пиксель выходного окна), с предыдущих стадий и вычисляет соответствующие ему значений, которые 
будут далее будут записаны в буферы цвета, глубины и др. на соответствующее фрагменту место.
\end{itemize}

\subsubsection{Настраиваемая функциональность}
Нас будут интересовать лишь две настраиваемых функциональности: 
\begin{enumerate}
\item Буфер глубины, stencil буфер 
и предоставляемые ими: тест глубины, решающий расположен ли новый фрагмент ближе или 
дальше, чем ранее обработанный фрагмент в том же пикселе окна; stencil-тест,
который на основе предыдущих решений теста глубины может запретить генерацию фрагментов в 
определенном пикселе окна.
\item Смешивание (англ.~blending) новых и старых данных буфера, настраивающий формулы, по которым
эти данные комбинируются.
\end{enumerate}

\subsection{Метод проекции на буфер глубины}\label{impl_volume_decals}
Каждый элемент разбиения кусочно-линейного скелета (см.~\ref{subdivision}) 
отправляется на графический конвейер как отдельная вершина, при этом вся информация об этом
элементе такая, как (для каждой вершины трапеции или треугольника): координаты в мировой 
системе координат, аппроксимации производных и 
береговые координаты, сохраняется как вершинные данные, которые вершинный шейдер передает далее
без изменений.

Затем геометрический шейдер генерирует из полученных данных прямоугольную трапецию, основаниями 
которых служат элементы разбиения, смещенные на такие высоты, чтобы призма полностью 
заключала в себя ландшафт или водную поверхность, проекции которых вдоль высоты лежат внутри
элемента разбиения. Эта призма затем проходит стадию растеризации и попавшие в нее фрагменты
обрабатываются согласно алгоритмам во фрагментном шейдере.

\subsection{Представление шума, и других функций на стадии отрисовки}
Функции $g$, $\mathrm{noise}_\mathrm{lf}$, $\mathrm{noise}_\mathrm{hf}$ и $\phi$, о которых 
шла речь в разделе (\ref{trains}), определяются некоторым периодичным образом, затем 
значение каждой функции за один сохраняется в виде текстур \emph{OpenGL}, доступных фрагментному 
шейдеру. Затем, используя встроенные в графическую библиотеку возможности, значения на периоде 
распространяются на все соответствующие области определения прозрачным для программиста 
фрагментного шейдера образом.

\subsection{Интеграция с коммерческой системой визуализации \emph{Frigate}}
Поскольку в рамках данной системы визуализации g-буферы, используемые при
визуализации ландшафта и водной поверхности, полностью разделены между собой (кроме 
буфера глубины), то запуск визуализации эффекта <<мокрого песка>> отделен это 
запуска эффектов наката прибрежной волны и прибоя.

Эффекты наката прибрежной волны и прибоя действуют на непересекающихся областях: 
первый визуализирует водную поверхность и прибой на ландшафте, непокрытым водой; а
второй накладывается уже поверх готовой водной поверхности, и поэтому не требует дополнительных 
вычислительных ресурсов на ее визуализацию. Для того, чтобы сэкономить число 
обрабатываемых фрагментов, в тот время, когда система \emph{Frigate} ведет отрисовку
водной поверхность поверх ландшафта, графический конвейер настраивается таким образом, чтобы
пиксели, на которые попали прошедшие тест глубины фрагменты некоторым образом 
помечались в stencil-буфере. В результате этого эффекты, реализующие и не реализующие внутри себя
механизм визуализации водной поверхности, могут определить: в каких пикселях изображения они
должны отрисовываться, а в каких --- нет, и отбросить ненужные фрагменты.

Приближенно схему интеграции эффектов в общий процесс визуализации можно изобразить следующей
последовательностью действий:
\begin{enumerate}
\item Запись данных материала ландшафта в G-буфер.
\item Модификация данных ландшафта эффектом <<мокрого песка>>
\item Освещение ландшафта на основе данных G-буфера.
\item Очистка stencil-буфера.
\item Запись данных материала водной поверхности в G-буфер. Фрагменты, прошедшие
тест глубины оставляют пометку в stencil-буфере.
\item Модификация данных водной поверхности эффектом, не включающем в себя материал воды, на
тех пикселях G-буфера, которые оказались помечены в stencil-буфере.
\item Перезапись эффектом прибоя, включающем в себя материал воды, 
данных ландшафта на тех пикселях, которые оказались непомечены в stencil-буфере и требуют наличия воды.
\item Освещение водной поверхности на основе данных G-буфера.
\end{enumerate}