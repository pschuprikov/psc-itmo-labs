\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\author{Чуприков Павел Сергеевич \\ группа 4539}
\title{Отчет по курсовой работе по предмету: <<Информационный поиск>>}
\begin{document}
\begin{titlepage}
\thispagestyle{empty}
\begin{center}
Санкт-Петербургский национальный исследовательский университет 
информационных технологий, механики и оптики\\
\smallskip
Факультет информационных технологий и программирования
\smallskip
Кафедра компьютерных технологий
\vspace{2cm}
\large{Чуприков Павел Сергеевич}\\
\vspace{1cm}
\begin{LARGE}
Отчет о курсовой работе по предмету: <<Информационный поиск>>\\
\end{LARGE}
\vfill
\today
\end{center}
\end{titlepage}

\setcounter{page}{2}
\tableofcontents
\pagebreak
\section{Введение}
Информационный поиск изучает поиск документов без структуру, удовлетворяющий 
потребности пользователя. Взаимодействие пользователя и системы информационного 
поиска можно кратко описать следующим образом:
\begin{enumerate}
\item Пользователь вводит некоторый запрос, возможно имеющий 
специализированный синтаксис для поиска цитат или других подсказок поисковой системе.
\item В ответ система возвращает список документов, которые, предполагается, 
пользователь хотел увидеть в ответ на данный им запрос.
\end{enumerate}

Конвейер информационного поиска включает в себя множество подзадач, начиная
с получения документов из сети Интернет и  индексации (процесс предобработки 
документов, имеющий целью ускорить операции, выполнение которых в дальнейшем 
потребуются для удовлетворения запроса пользователя), заканчивая ранжированием 
(численная оценка полезности для пользователя найденных документов) и 
обработкой реакции пользователя на предоставленную информацию.


В данной работе рассматривались следующие подзадачи, результаты работы
которых, тем не менее, можно наглядно продемонстрировать в изоляции от 
остального конвейера:
\begin{itemize}
\item Выбор инструментов и методов хранения индекса;
\item Индексирование документов с позиционными данными;
\item Поиск соответствующих запросу документов в индексе, включая:
    \begin{itemize}
        \item конъюнкция запросов;
        \item цитатный поиск;
        \item поиск с заданным расстоянием между словами;
        \item поиск с мета-символами.
    \end{itemize}
\end{itemize}

Основным вопросом информационного, не затрагивающегося в данной работе остается ранжирование документов.

\section{Постановка задачи}
\subsection{Выбор инструментов и методов хранения данных}
В данную подзадачу включаются все решения о формате и способах хранения
индекса и других сопутствующих данных, необходимых для информационному поиску.
Так как необходимо будет работать с большими объемами данных, то высокая 
производительность, и экономное использование дискового пространства, 
являются основными требованиями к подсистеме хранения данных.

В качестве дополнительного критерия учитывалась также простота взаимодействия с 
базой данной при использовании языка \emph{Java}.

\subsection{Индексирование документов с позиционными данными}
Индекс, или точнее обратный индекс (англ.~inverted index) представляет собой структуру
данных, которая хранит для каждого термина список документов, в которых данный термин встречался
, наряду с дополнительной информацией --- позициями вхождений. 
Эта структура данных должна эффективно выполнять операцию пересечения вышеназванных списков, 
поскольку она составляет основу информационного поиска и легко может быть
узким местом системы поиска в целом.

Итак, во-первых, необходимо реализовать алгоритм построения индекса, удовлетворяющий следующим требованиям:
\begin{itemize}
\item информация о позициях вхождения терминов в документ должна сохранятся;
\item размер словаря терминов может не умещаться в оперативную память;
\item список вхождения отдельного термина может не умещаться в оперативную память;
\item возможность добавлять в индекс новые документы;
\item построение индекса должно эффективно использовать имеющуюся систему хранения данных;
\end{itemize}

Во-вторых необходимо в координации с первой подзадачей обеспечить эффективное выполнение
пересечений списков вхождений и обработку позиционных данных, используемых для
выполнения специфичных запросов из следующего подраздела.

\subsection{Поиск соответствующих запросу документов в индексе}
Требуется на основании двух предыдущих подзадач реализовать алгоритм
поиска документов, поддерживающий следующие виды запросов:
\begin{itemize}
\item конъюнкция запросов: \textbf{ориентированный граф};
\item цитатный запрос: \textbf{"ACM ICPC"};
\item запросы с заданной близостью: \textbf{девушка /6 военными};
\item запросы с метасимволами: \textbf{стр*труп}.
\end{itemize}

\section{Реализация}

\subsection{Выбор инструментов и методов хранения данных}
Для хранения индекса и сопутствующей информации была выбранна база данных
\emph{Berkeley DB Java Edition}, использующая в качестве модели данных пары ключ-значение.
При выборе в качестве решающих выступили следующие факторы:
\begin{itemize}
\item относительно высокая производительность;
\item возможность компактного представления записей в базе данных;
\item встроенная поддержка составного парного ключа (окажется полезным при хранении индекса).
\item поддержка запросов \emph{upper bound}/\emph{bound};
\item простота интеграции с Java;
\end{itemize}

\paragraph{Обратный индекс.} Так как список вхождений какого-либо одного термина может не помещаться в оперативной 
памяти компьютера, решено было разбить упорядоченные списки вхождений для некоторого
термина, имеющего идентификатор $\mathrm{termID}$ вида 
$<(\mathrm{docID}_0, \mathrm{positions}_0), \ldots>$ на кусочки. 
Хранить эти кусочки можно отдельно используя в качестве ключа для 
кусочка $<(\mathrm{docID}_n, \mathrm{positions}_n), \ldots>$
кортеж $<\mathrm{termID}, \mathrm{docID}_n>$. Таким образом найти 
первый кусок для заданного термина можно за $O(\log(\mathrm{numberOfTerms}))$, 
найти кусок, соответствующий определенному документу
можно за $O(\log(\mathrm{numberOfBits}[\mathrm{termID}]))$, а итерация по списку 
вхождений для заданного термина требует $O(\mathrm{numberOfBits}[\mathrm{termID}])$, 
при этом всегда достаточно хранить в памяти только один кусок.

Хранить каждое вхождение $(\mathrm{docID}_n, \mathrm{positions}_0)$ отдельно 
было сочтено нецелесообразным, потому как это включает дополнительные расходы по памяти, внесенные
базой данных, и увеличение времени итерации, поскольку для каждого следующего вхождение 
необходимо обращение к базе данных.

\paragraph{Сопутствующая информация} Для хранения словаря и списка k-грамм
использовалась обертка \emph{Berkeley DB JE Collections}, с ручной сериализацией для
более эффективного использования памяти.

\section{Индексирование документов с позиционными данными}
Для построения индекса использовался алгоритм \emph{SPIMI} 
(Single-Pass In Memory Indexing), работающий за время пропорциональное числу вхождений. 
Кратко его можно описать следующим образом:
\begin{enumerate}
\item входная информация о вхождении терминов в документ, поступающая в виде
$(\mathrm{term}, \mathrm{docID}, \mathrm{positions})$, разбивается на кусочки, которые можно обработать в оперативной памяти.
\begin{enumerate}
    \item Для каждого кусочка $\mathrm{bit}_i = <(\mathrm{term_0}, \mathrm{docID_0}, \mathrm{positions_0}) \ldots (\mathrm{term_n}, \mathrm{docID_n}, \mathrm{positions_n})>$
строится обратный индекс
    \item Термины вместе с соответствующими им списками вхождений 
    упорядочиваются по алфавиту и сохраняются в отдельный файл во внешней памяти.
\end{enumerate}
\item Списки из внешней памяти для каждого отдельного термина затем сливаются. 
Благодаря упорядочиванию списков в отдельном файле по термину, и вхождений внутри 
списка по $\mathrm{docID}$. Сливание можно полностью провести в оперативной памяти, 
аналогично алгоритму сортировки слиянием.
\end{enumerate}

Для создания временного словаря, и отображения термина в соответствующий список,
использовалась структура данных хэш-таблица, представленная в стандартной библиотеке
$Java$ классом $HashMap$. Для сериализации списков вхождений и позиций вхождений всюду
использовалась библиотека \emph{protobuf}.

Заметим, что формат хранения позволяет легко добавлять новые документы, разумеется 
предполагая, что соответствующие им $\mathrm{docID}$ постоянно возрастают. Для
добавления к списку вхождений новых элементов требуется хранить и обновлять в памяти 
только один кусок списка вхождений.


\end{document}